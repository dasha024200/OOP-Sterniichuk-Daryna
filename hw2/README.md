# HW2 — Приклади порушення LSP (не Square/Rectangle)

## Що таке LSP (Liskov Substitution Principle)
Якщо `S` є підтипом `T`, то об’єкти типу `T` мають бути взаємозамінні з об’єктами типу `S` **без зміни коректності роботи програми**.
Тобто підклас не повинен:
- послаблювати гарантії базового класу (ламати інваріанти),
- змінювати поведінку так, що клієнтський код, який очікує `T`, “падає” або працює неправильно з `S`.

---

## Приклад 1: `Bird` → `Penguin` (або `Ostrich`)
### Поганий дизайн (порушує LSP)
Є базовий клас `Bird`, який має метод `Fly()`:
- `Sparrow : Bird` літає — ок
- `Penguin : Bird` не літає → реалізація `Fly()` кидає виняток / нічого не робить

**Чому це порушує LSP**
Клієнтський код працює з `Bird` і логічно очікує, що `Fly()` доступний і коректний:
- Якщо підставити `Penguin`, отримаємо виняток або некоректну поведінку.
Отже `Penguin` не може бути повноцінною заміною `Bird`.

**Які проблеми викликає**
- runtime-помилки (`NotSupportedException`)
- потреба в `if (bird is Penguin)` у клієнтському коді → розростання умов і ламання поліморфізму
- складність тестування і підтримки

### Як перепроєктувати під LSP
Розділити абстракції:
- `Bird` без `Fly()`
- окремий інтерфейс `IFlyable` для птахів, що літають

Тоді:
- `Sparrow : Bird, IFlyable`
- `Penguin : Bird` (без `IFlyable`)

---

## Приклад 2: `Account` → `FixedDepositAccount` (рахунок з обмеженнями)
### Поганий дизайн (порушує LSP)
Є базовий клас `Account`, який має `Withdraw(amount)` і гарантує можливість зняття (якщо достатньо коштів).
Підклас `FixedDepositAccount` (депозит) **забороняє** `Withdraw` до кінця терміну → кидає виняток або ігнорує операцію.

**Чому це порушує LSP**
Код, який працює з `Account`, очікує контракт:
- якщо баланс достатній → `Withdraw` успішний
Але з `FixedDepositAccount` це не так. Підклас посилює передумови (тепер ще треба “закінчився термін”), тобто ламає контракт базового класу.

**Які проблеми викликає**
- фінансові операції стають непередбачуваними
- клієнтський код вимушений перевіряти тип/стан рахунку
- логіка “вилізає” назовні і дублюється

### Як перепроєктувати під LSP
Варіант A (кращий): розділити інтерфейси можливостей
- `IAccount` (Balance, Deposit)
- `IWithdrawableAccount` (Withdraw)
- `FixedDepositAccount : IAccount` (без Withdraw)
- `CurrentAccount : IAccount, IWithdrawableAccount`

Варіант B: контракт через результат, а не через виняток
- `TryWithdraw(amount)` → повертає `true/false`
Але все одно важливо: якщо базовий тип обіцяє можливість зняття, депозит не має його наслідувати.

---

## Приклад 3: `Logger` → `FileLogger` (зміна контракту через винятки/передумови)
### Поганий дизайн (порушує LSP)
Базовий `Logger` має метод `Log(string message)` і клієнт розраховує:
- логування **ніколи не зриває** основний сценарій (максимум — “проковтнули” помилку або записали в fallback)

Але `FileLogger : Logger` вимагає:
- щоб був доступний шлях/диск/права
і при помилці кидає виняток, який валить бізнес-логіку.

**Чому це порушує LSP**
Підклас “погіршує” гарантії базового типу:
- базовий логер безпечний (не ламає потік)
- файловий — може кинути виняток і змінити поведінку програми
Отже підстановка `FileLogger` замість `Logger` змінює коректність роботи.

**Які проблеми викликає**
- падіння програми через допоміжну функцію (логування)
- приховані залежності (файлова система, права доступу)
- нестабільність у продакшні

### Як перепроєктувати під LSP
Варіант A: зафіксувати контракт “логер не кидає”
- `Log()` не кидає винятків, а помилки обробляє всередині (fallback, буфер, console, noop)

Варіант B: якщо помилки важливі — змінити API на явний результат
- `Log()` повертає `Result/boolean`, а клієнт свідомо вирішує, що робити

Варіант C: композиція
- `SafeLogger` обгортає будь-який `ILogger` і гарантує “не кидати”, логуючи помилки в резервне місце

---

## Висновок
Порушення LSP зазвичай проявляється, коли:
- підклас **кидає виняток** там, де базовий клас обіцяє нормальну роботу,
- підклас **посилює передумови** (потрібно більше умов для коректної роботи),
- підклас **ламає інваріанти/очікування** клієнтського коду.

Найчастіші виправлення:
- **розділення інтерфейсів** за можливостями (capabilities),
- **композиція замість наслідування**,
- **явні контракти** через повернення результату замість прихованих винятків.
