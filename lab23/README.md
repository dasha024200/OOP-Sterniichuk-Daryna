# Lab23 — ISP & DIP + Constructor DI (Variant 7: Vehicle Management)

## Мета
Застосувати принципи ISP та DIP і реалізувати DI через конструктор для зменшення зв’язаності та покращення тестування.

## Варіант 7: CarComputer
CarComputer керує двигуном, радіо та навігацією.

## Код ДО рефакторингу (порушення ISP та DIP)
- Інтерфейс `ICarSystem` містив методи для двигуна, радіо і GPS одночасно.
- `CarComputer_Legacy` створював `EngineUnit`, `RadioTuner`, `GPSModule` всередині класу.

### Де порушено ISP
Клієнт, якому потрібен лише двигун, змушений залежати від методів радіо та навігації (`SetRadioStation`, `NavigateTo` тощо).

### Де порушено DIP
Модуль вищого рівня (`CarComputer_Legacy`) напряму залежить від низькорівневих реалізацій (`EngineUnit`, `RadioTuner`, `GPSModule`) та створює їх сам, що ускладнює заміну й тестування.

## Рефакторинг (ISP)
Інтерфейс було розділено на вузькі:
- `IEngineControl`
- `IRadioControl`
- `INavigation`

## Рефакторинг (DIP + DI)
`CarComputer` приймає залежності через конструктор:
- `IEngineControl engine`
- `IRadioControl radio`
- `INavigation navigation`

Таким чином, CarComputer залежить від абстракцій, а конкретні реалізації конфігуруються в `Main`.

## Висновок
Після рефакторингу код став більш гнучким і тестованим: клієнти залежать лише від потрібних інтерфейсів (ISP), а модуль вищого рівня не залежить від конкретних реалізацій і отримує залежності через DI (DIP).
